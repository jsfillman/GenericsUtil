# -*- coding: utf-8 -*-
############################################################
#
# Autogenerated by the KBase type compiler -
# any changes made here will be overwritten
#
############################################################

from __future__ import print_function
# the following is a hack to get the baseclient to import whether we're in a
# package or not. This makes pep8 unhappy hence the annotations.
try:
    # baseclient and this client are in a package
    from .baseclient import BaseClient as _BaseClient  # @UnusedImport
except:
    # no they aren't
    from baseclient import BaseClient as _BaseClient  # @Reimport


class GenericsUtil(object):

    def __init__(
            self, url=None, timeout=30 * 60, user_id=None,
            password=None, token=None, ignore_authrc=False,
            trust_all_ssl_certificates=False,
            auth_svc='https://kbase.us/services/authorization/Sessions/Login'):
        if url is None:
            raise ValueError('A url is required')
        self._service_ver = None
        self._client = _BaseClient(
            url, timeout=timeout, user_id=user_id, password=password,
            token=token, ignore_authrc=ignore_authrc,
            trust_all_ssl_certificates=trust_all_ssl_certificates,
            auth_svc=auth_svc)

    def import_csv(self, params, context=None):
        """
        :param params: instance of type "ImportCSVParams" -> structure:
           parameter "file" of type "File" (Import a CSV file into a NDArray
           or HNDArray. "File" and "usermeta" are common to all import
           methods.) -> structure: parameter "path" of String, parameter
           "shock_id" of String, parameter "workspace_name" of String,
           parameter "object_name" of String, parameter "object_type" of
           String, parameter "metadata" of type "usermeta" -> mapping from
           String to String
        :returns: instance of type "ImportResult" -> structure: parameter
           "object_ref" of String
        """
        return self._client.call_method(
            'GenericsUtil.import_csv',
            [params], self._service_ver, context)

    def import_obo(self, params, context=None):
        """
        :param params: instance of type "ImportOBOParams" (Import an OBO file
           into an OntologyDictionary) -> structure: parameter "file" of type
           "File" (Import a CSV file into a NDArray or HNDArray. "File" and
           "usermeta" are common to all import methods.) -> structure:
           parameter "path" of String, parameter "shock_id" of String,
           parameter "workspace_name" of String, parameter "object_name" of
           String, parameter "metadata" of type "usermeta" -> mapping from
           String to String
        :returns: instance of type "ImportResult" -> structure: parameter
           "object_ref" of String
        """
        return self._client.call_method(
            'GenericsUtil.import_obo',
            [params], self._service_ver, context)

    def export_csv(self, params, context=None):
        """
        :param params: instance of type "ExportParams" (Exporter for generic
           objects as CSV files) -> structure: parameter "input_ref" of String
        :returns: instance of type "ExportResult" -> structure: parameter
           "shock_id" of String
        """
        return self._client.call_method(
            'GenericsUtil.export_csv',
            [params], self._service_ver, context)

    def list_generic_objects(self, params, context=None):
        """
        :param params: instance of type "ListGenericObjectsParams" (List
           generic objects in one or more workspaces optional parameters:
           allowed_object_types - limits to specific types of object, e.g.,
           KBaseGenerics.NDArray (version number is optional)
           allowed_data_types - limits to specific data types, e.g.,
           microbial growth allowed_scalar_types - limits to specific scalar
           types, e.g., object_ref, int, float (see KBaseGenerics.spec for
           valid types).  HNDArrays must have at least one dimension that
           passes. min_dimensions - limits to generics with minimum number of
           dimensions max_dimensions - limits to generics with max number of
           dimensions limit_mapped - if 0 (or unset) returns all objects.  if
           1, returns only mapped objects.  if 2, returns only umapped
           objects) -> structure: parameter "workspace_names" of list of
           String, parameter "allowed_object_types" of list of String,
           parameter "allowed_data_types" of list of String, parameter
           "allowed_scalar_types" of list of String, parameter
           "min_dimensions" of Long, parameter "max_dimensions" of Long,
           parameter "limit_mapped" of Long
        :returns: instance of type "ListGenericObjectsResult" -> structure:
           parameter "object_ids" of list of String
        """
        return self._client.call_method(
            'GenericsUtil.list_generic_objects',
            [params], self._service_ver, context)

    def get_generic_metadata(self, params, context=None):
        """
        :param params: instance of type "GetGenericMetadataParams" (Get
           metadata describing the dimensions of one or more generic objects)
           -> structure: parameter "object_ids" of list of String
        :returns: instance of type "GetGenericMetadataResult" (maps object
           ids to structure with metadata) -> structure: parameter
           "object_info" of mapping from String to type "GenericMetadata"
           (Basic metadata about an object: object_type - e.g.,
           KBaseGenerics.HNDArrayâ€‘4.0 data_type - e.g., microbial growth
           n_dimensions - number of dimensions is_mapped - 0 or 1 indicating
           mapped status value_types - list of value types in the object
           (there will only be 1 for NDArray objects), e.g., "specific
           activity" scalar_types - list of scalar types in the object (there
           will only be 1 for NDArray objects), e.g., "float" dimension_types
           - a string describing each dimension (e.g., "media name")
           dimension_sizes - size (length) of each dimension
           dimension_value_types - a string describing each context of each
           dimension (e.g., "media name") dimension_scalar_types - type of
           values in each context of each dimension (e.g., "int")) ->
           structure: parameter "object_type" of String, parameter
           "data_type" of String, parameter "n_dimensions" of Long, parameter
           "is_mapped" of type "boolean", parameter "value_types" of list of
           String, parameter "scalar_types" of list of String, parameter
           "dimension_types" of list of String, parameter "dimension_sizes"
           of list of Long, parameter "has_unique_subindices" of list of type
           "boolean", parameter "dimension_value_types" of list of list of
           String, parameter "dimension_scalar_types" of list of list of
           String
        """
        return self._client.call_method(
            'GenericsUtil.get_generic_metadata',
            [params], self._service_ver, context)

    def get_generic_dimension_labels(self, params, context=None):
        """
        :param params: instance of type "GetGenericDimensionLabelsParams"
           (gets labels for list of dimension axes for a generic object. User
           will pass in the numeric indices of all dimensions they care about
           (e.g., 1/1 will mean 1st dimension, 1st data type, 2/1 = 2nd
           dimension, 1st data type), and an optional flag,
           convert_to_string. The API will return a hash mapping each of the
           dimension indices to a Values object.  The Values will either
           contain the scalar type in the original format, or if the
           convert_to_string flag is set, will convert the scalar type to
           strings.  If unique_values is set, the API will only return the
           unique values in each dimension (these will also be re-indexed,
           but not resorted, so the Values array may be a different length).)
           -> structure: parameter "object_id" of String, parameter
           "dimension_ids" of list of String, parameter "convert_to_string"
           of type "boolean", parameter "unique_values" of type "boolean"
        :returns: instance of type "GetGenericDimensionLabelsResult" ->
           structure: parameter "dimension_labels" of mapping from String to
           type "Values" (@optional object_refs oterm_refs int_values
           float_values string_values boolean_values) -> structure: parameter
           "scalar_type" of type "data_type", parameter "object_refs" of list
           of type "object_ref", parameter "oterm_refs" of list of type
           "oterm_ref", parameter "int_values" of list of Long, parameter
           "float_values" of list of Double, parameter "boolean_values" of
           list of type "boolean", parameter "string_values" of list of String
        """
        return self._client.call_method(
            'GenericsUtil.get_generic_dimension_labels',
            [params], self._service_ver, context)

    def get_generic_data(self, params, context=None):
        """
        :param params: instance of type "GetGenericDataParams" (gets subset
           of generic data as a 2D matrix Users passes in the dimension
           indices to use as variables (1st one must be X axis; additional
           variables will lead to additional series being returned). User
           selects which dimension indices to fix to particular constants. 
           This can be done one of two ways:  either by fixing an entire
           dimension (e.g., "2" for the 2nd dimension) to an index in the
           complete list of labels, or by fixing a dimension index (e.g.,
           "2/3" for the 3rd type of values in the 2nd dimension) to an index
           in the list of unique labels for that dimension index. returns:
           series_labels will show which variable index values correspond to
           which series values_x will contain 1 list of of x-axis values per
           series.  The number of series depends on the number of variable
           dimensions. values_y will contain 1 list of of y-axis values per
           series.  The number of series depends on the number of variable
           dimensions. In each series, values where either the X and Y data
           are null are removed.) -> structure: parameter "object_id" of
           String, parameter "variable_dimension_ids" of list of String,
           parameter "constant_dimension_ids" of mapping from String to Long
        :returns: instance of type "GetGenericDataResult" -> structure:
           parameter "series_labels" of list of String, parameter "values_x"
           of list of type "Values" (@optional object_refs oterm_refs
           int_values float_values string_values boolean_values) ->
           structure: parameter "scalar_type" of type "data_type", parameter
           "object_refs" of list of type "object_ref", parameter "oterm_refs"
           of list of type "oterm_ref", parameter "int_values" of list of
           Long, parameter "float_values" of list of Double, parameter
           "boolean_values" of list of type "boolean", parameter
           "string_values" of list of String, parameter "values_y" of list of
           type "Values" (@optional object_refs oterm_refs int_values
           float_values string_values boolean_values) -> structure: parameter
           "scalar_type" of type "data_type", parameter "object_refs" of list
           of type "object_ref", parameter "oterm_refs" of list of type
           "oterm_ref", parameter "int_values" of list of Long, parameter
           "float_values" of list of Double, parameter "boolean_values" of
           list of type "boolean", parameter "string_values" of list of String
        """
        return self._client.call_method(
            'GenericsUtil.get_generic_data',
            [params], self._service_ver, context)

    def status(self, context=None):
        return self._client.call_method('GenericsUtil.status',
                                        [], self._service_ver, context)
